/**
 * @file	CStateEstimate.cpp
 * @author	Michael Meindl
 * @date	16.02.2017
 * @brief	Method definitions for CStateEstimate.h
 */
#include "CStateEstimate.h"

CStateEstimate::CStateEstimate() :
	mA_X_PolyArr{ {sA_X1_P1, sA_X1_P2}, {sA_X2_P1, sA_X2_P2},
				  {sA_X3_P1, sA_X3_P2}, {sA_X4_P1, sA_X4_P2},
				  {sA_X5_P1, sA_X5_P2}, {sA_X6_P1, sA_X6_P2} },
	mA_Y_PolyArr{ {sA_Y1_P1, sA_Y1_P2}, {sA_Y2_P1, sA_Y2_P2},
				  {sA_Y3_P1, sA_Y3_P2}, {sA_Y4_P1, sA_Y4_P2},
				  {sA_Y5_P1, sA_Y5_P2}, {sA_Y6_P1, sA_Y6_P2} },
	mW_X_PolyArr{ {sW_P1, sW_X1_P2}, {sW_P1, sW_X2_P2},
				  {sW_P1, sW_X3_P2}, {sW_P1, sW_X4_P2},
				  {sW_P1, sW_X5_P2}, {sW_P1, sW_X6_P2} },
	mW_Y_PolyArr{ {sW_P1, sW_Y1_P2}, {sW_P1, sW_Y2_P2},
				  {sW_P1, sW_Y3_P2}, {sW_P1, sW_Y4_P2},
				  {sW_P1, sW_Y5_P2}, {sW_P1, sW_Y6_P2} },
	mW_Z_PolyArr{ {sW_P1, sW_Z1_P2}, {sW_P1, sW_Z2_P2},
				  {sW_P1, sW_Z3_P2}, {sW_P1, sW_Z4_P2},
				  {sW_P1, sW_Z5_P2}, {sW_P1, sW_Z6_P2} },
    mADC_PolyArr{ {sADC1_P1, sADC1_P2}, {sADC2_P1, sADC2_P2}, {sADC3_P1, sADC3_P2} }
{

}
const CStateData& CStateEstimate::calculateOutput(const CSensorData& input)
{
	this->calculateG(input);
	this->calculateUK(input);
	this->calculateUR(input);
}
void CStateEstimate::calculateG(const CSensorData& input)
{
	mOutput.mGData.mG_k1 =
}
void CStateEstimate::calculateUK(const CSensorData& input)
{
	mOutput.mUKData.mUK_k1 = (mW_Y_PolyArr[0].calcOutput(static_cast<Float32>(input.mSensor1Data.mW_y)) +
						      mW_Y_PolyArr[1].calcOutput(static_cast<Float32>(input.mSensor2Data.mW_y)) +
							  mW_Z_PolyArr[2].calcOutput(static_cast<Float32>(input.mSensor3Data.mW_z)) +
							  mW_Z_PolyArr[3].calcOutput(static_cast<Float32>(input.mSensor4Data.mW_z)) +
							  mW_X_PolyArr[4].calcOutput(static_cast<Float32>(input.mSensor5Data.mW_x)) +
							  mW_X_PolyArr[5].calcOutput(static_cast<Float32>(input.mSensor6Data.mW_x))) / 6.0F;

	mOutput.mUKData.mUK_k2 = (mW_X_PolyArr[0].calcOutput(static_cast<Float32>(input.mSensor1Data.mW_x)) +
							  mW_X_PolyArr[1].calcOutput(static_cast<Float32>(input.mSensor2Data.mW_x)) +
							  mW_Y_PolyArr[2].calcOutput(static_cast<Float32>(input.mSensor3Data.mW_y)) +
							  mW_Y_PolyArr[3].calcOutput(static_cast<Float32>(input.mSensor4Data.mW_y)) +
							  mW_Z_PolyArr[4].calcOutput(static_cast<Float32>(input.mSensor5Data.mW_z)) +
							  mW_Z_PolyArr[5].calcOutput(static_cast<Float32>(input.mSensor6Data.mW_z))) / 6.0F;

	mOutput.mUKData.mUK_k3 = (mW_Z_PolyArr[0].calcOutput(static_cast<Float32>(input.mSensor1Data.mW_z)) +
							  mW_Z_PolyArr[1].calcOutput(static_cast<Float32>(input.mSensor2Data.mW_z)) +
							  mW_X_PolyArr[2].calcOutput(static_cast<Float32>(input.mSensor3Data.mW_x)) +
							  mW_X_PolyArr[3].calcOutput(static_cast<Float32>(input.mSensor4Data.mW_x)) +
							  mW_Y_PolyArr[4].calcOutput(static_cast<Float32>(input.mSensor5Data.mW_y)) +
							  mW_Y_PolyArr[5].calcOutput(static_cast<Float32>(input.mSensor6Data.mW_y))) / 6.0F;
}
void CStateEstimate::calculateUR(const CSensorData& input)
{
	mOutput.mURData.mUR_k1 = mOutput.mUKData.mUK_k1 + mADC_PolyArr[0].calcOutput(static_cast<Float32>(input.mADCData.mADC1Value));
	mOutput.mURData.mUR_k2 = mOutput.mUKData.mUK_k2 + mADC_PolyArr[1].calcOutput(static_cast<Float32>(input.mADCData.mADC2Value));
	mOutput.mURData.mUR_k3 = mOutput.mUKData.mUK_k3 + mADC_PolyArr[2].calcOutput(static_cast<Float32>(input.mADCData.mADC3Value));
}
