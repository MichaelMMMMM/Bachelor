#include "CADC.h"
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys/mman.h>
#include "Global.h"

CADC::CADC() : mMemoryFD(-1), mAddrPtr(nullptr)
{
	mMemoryFD = open("/dev/mem", O_RDWR);
	sAssertion(mMemoryFD >= 0, "(CSPI::CSPI) Failed to open /dev/mem", true);
	mAddrPtr = reinterpret_cast<UInt8*>(mmap(0, sMEM_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, mMemoryFD, sSTART_ADDR));
	//sAssertion(reinterpret_cast<void*>(mAddrPtr) != MAP_FAILED, "(SPI::CSPI) Failed to mmap", true);

	this->writeRegister(sCTRL_Offset, 0b010U);
	this->writeRegister(sSTEPCONFIG1_Offset, cBIT26 | cBIT4  | cBIT0);
	this->writeRegister(sSTEPCONFIG2_Offset, cBIT26 | cBIT19 | cBIT4 | cBIT0)
}
CADC::~CADC()
{

}
void CADC::writeRegister(const UInt32 addrOffset, const UInt32 value)
{
	*reinterpret_cast<UInt32*>(mAddrPtr + addrOffset) = value;
}
UInt32 CADC::readRegister(const UInt32 addrOffset)
{
	return *reinterpret_cast<UInt32*>(mAddrPtr + addrOffset);
}
bool CADC::readADCValues(UInt16& adc1, UInt16& adc2, UInt16& adc3, bool wait)
{
	bool finished = false;
	do
	{
		UInt32 fifo1Count = this->readRegister(sFIFO1COUNT_Offset);
		if(fifo1Count >= 3U)
		{
			finished = true;
			for(UInt32 i = 0U; i < 3U; i++)
			{
				UInt16 value = this->readRegister(sFIFO1DATA_Offset);
				UInt16 id    = ( value & sIDMask) >> 16U;
				value 		 = ( value & sValueMask);
				switch(id)
				{
				case sChannel1ID:
				{
					adc1 = value;
					break;
				}
				case sChannel2ID:
				{
					adc2 = value;
					break;
				}
				case sChannel3ID:
				{
					adc3 = value;
					break;
				}
				default:
				{
					break;
				}
				}
			}
		}
	}while( (finished == false) && (wait == true));
	return finished;
}
