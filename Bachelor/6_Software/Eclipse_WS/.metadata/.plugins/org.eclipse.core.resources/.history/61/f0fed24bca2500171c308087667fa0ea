/**
 * @file	CCornerBalanceAction.cpp
 * @author	Michael Meindl
 * @date	20.04.2017
 * @brief	Method definitions for CCornerBalanceAction.
 */
#include "CCornerBalanceAction.h"
#include <iostream>

CCornerBalanceAction::CCornerBalanceAction() : mTime(0.0F), mDelayCounter(0U)
{
	mSignalFlow.TLQR<9U, 3U>::init("config/Corner_Kd.csv");
}
void CCornerBalanceAction::entryCornerBalance()
{
	std::cout << "[*] Control-Comp: Entering Corner-Balance . . . " << std::endl;
	mTime = 0.0F;
	sTimerTask.setPeriodMS(20);
	sTimerTask.resume(true);
	mSignalFlow.C3DCompFilter::reset();
}
void CCornerBalanceAction::exitCornerBalance()
{
	std::cout << "[*] Control-Comp: Exiting Corner-Balance . . . " << std::endl;
	sTimerTask.pause(true);
}
void CCornerBalanceAction::entryIdle()
{
	std::cout << "[*] Control-Comp: Entering Corner-Balance/Idle . . ." << std::endl;
}
void CCornerBalanceAction::exitIdle()
{
	std::cout << "[*] Control-Comp: Exiting Corner-Balance/Idle . . . " << std::endl;
}
void CCornerBalanceAction::entryBalance()
{
	std::cout << "[*] Control-Comp: Entering Corner-Balance/Balance . . . " << std::endl;
	sHardware.enableMotor();
}
void CCornerBalanceAction::exitBalance()
{
	std::cout << "[*] Control-Comp: Exiting Corner-Balance/Balance . . . " << std::endl;
	sHardware.disableMotor();
}
void CCornerBalanceAction::setTorques()
{
	TRVector<3U> u = mSignalFlow.TLQR<9U, 3U>::getValue();
	CTorqueData torque;
	torque.mTorque1 = u[1][1];
	torque.mTorque2 = u[2][1];
	torque.mTorque3 = u[3][1];
	sHardware.setTorque(torque);
}
bool CCornerBalanceAction::inBalanceArea()
{
	TRVector<3U> x = mSignalFlow.C3DCompFilter::getValue();
	Float32 phi2_abs = x[2][1] > 0.0F ? x[2][1] : - x[2][1];
	Float32 phi3_abs = x[3][1] > 0.0F ? x[3][1] : - x[3][1];

	if( (phi2_abs < sPhiMax) && (phi3_abs < sPhiMax) )
	{
		if(mDelayCounter >= 50U)
		{
			return true;
		}
		mDelayCounter++;
	}

}
