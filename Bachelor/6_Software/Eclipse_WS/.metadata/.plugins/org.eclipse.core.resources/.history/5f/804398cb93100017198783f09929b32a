/**
 * @file	TMatrix.h
 * @author	Michael Meindl
 * @date	24.03.2017
 * @brief	Template class to utilize matrixes.
 */
#ifndef TMATRIX_H
#define TMATRIX_H
#include "TCVector.h"

template<const UInt32 n_R, const UInt32 n_C>
class TMatrix
{
public:
	TCVector<n_C>& operator[](const UInt32 ic);
	TMatrix<n_R, n_C> operator+(const TMatrix<n_R, n_C>& summand) const;
	TMatrix<n_R, n_C> operator-(const TMatrix<n_R, n_C>& subtrahend) const;
	template<const UInt32 n_C_new>
	TMatrix<n_R, n_C_new> operator*(const TMatrix<n_C, n_C_new>& factor) const;
public:
	TMatrix();
	TMatrix(const TMatrix&) = default;
	TMatrix& operator=(const TMatrix&) = default;
	~TMatrix() = default;
private:
	TCVector<n_C> mMatrix[n_R];
};

template<const UInt32 n_R, const UInt32 n_C>
template<const UInt32 n_C_new>
TMatrix<n_R, n_C_new> TMatrix<n_R, n_C>::operator*(const TMatrix<n_C, n_C_new>& factor) const
{
	TMatrix<n_R, n_C_new> ret;
	for(UInt32 ir = 0; ir < n_R; ir++)
	{
		for(UInt32 ic = 0; ic < n_C_new; ic++)
		{
			for(UInt32 i = 0; i < n_C; i++)
			{

				ret[ir][ic] += this->mMatrix[ir][i] * factor[ir][ic];
			}
		}
	}
}
template<const UInt32 n_R, const UInt32 n_C>
TCVector<n_C> TMatrix<n_R, n_C>::operator[](const UInt32 i)
{
	return mMatrix[i];
}
template<const UInt32 n_R, const UInt32 n_C>
TMatrix<n_R, n_C> TMatrix<n_R, n_C>::operator+(const TMatrix<n_R, n_C>& summand) const
{
	TMatrix<n_R, n_C> ret;
	for(UInt32 ir = 0; ir < n_R; ir++)
	{
		ret.mMatrix[ir] = this->mMatrix[ir] + summand.mMatrix[ir];
	}
	return ret;
}
template<const UInt32 n_R, const UInt32 n_C>
TMatrix<n_R, n_C> TMatrix<n_R, n_C>::operator-(const TMatrix<n_R, n_C>& subtrahend) const
{
	TMatrix<n_R, n_C> ret;
	for(UInt32 ir = 0; ir < n_R; ir++)
	{
		ret.mMatrix[ir] = this->mMatrix[ir] - subtrahend.mMatrix[ir];
	}
	return ret;
}
template<const UInt32 n_R, const UInt32 n_C>
TMatrix<n_R, n_C>::TMatrix()
{

}

#endif
